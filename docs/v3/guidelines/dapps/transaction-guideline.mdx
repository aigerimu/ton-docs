# Interact with transactions

## Как мне выяснить что моя транзакция выполнилась успешно с помощью метода API?
//TODO briefing: what you will learn in this guide

## Терминология

### Общие термины
#### Актор

**Актор** — это абстрактная модель поведения, происходящая из _Actor model_ — модели параллельных вычислений, в которой каждый актор:
* изолирован от других,
* обрабатывает сообщения асинхронно,
* может порождать других акторов,
* реагирует на сообщения, изменяя только своё состояние.

В TON Блокчейн актором считается аккаунт с кодом (смарт-контрактом), который реализует эту модель, а именно:

* принимает входящие сообщения;
* выполняет код при получении сообщения;
* изменяет своё внутреннее состояние;
* отправляет исходящие сообщения другим акторам;
* может создавать новых акторов (новые аккаунты с кодом).


#### Асинхронность

**Асинхронность в TON** — это способ взаимодействия между акторами, при котором все сообщения обрабатываются отдельно и с задержкой.

Контракты не вызывают друг друга напрямую. Вместо этого они отправляют сообщения, которые попадают в очередь и обрабатываются в рамках отдельных транзакций. Это значит, что контракт не может сразу узнать, что произошло в другом контракте — он просто отправляет сообщение и ждёт результата.

> В отличие от синхронных блокчейнов, где можно сделать "вызов → получить ответ → принять решение", в TON каждое действие — это отдельная транзакция и её результат может прийти позже (или не прийти вовсе).

Асинхронность в TON повышает отказоустойчивость сети, то есть:
* если какой-то узел или смарт-контракт временно недоступен, это не приводит к остановке всей системы;
* другие части сети продолжают работать;
* данные и транзакции обрабатываются надёжно и последовательно, несмотря на возможные сбои.

Но это также требует:
* проектировать взаимодействие между контрактами более явно;
* вручную откатывать нежелательные изменения, если что-то пошло не так.

### Структура и взаимодействия акторов в TON
#### Аккаунт

**Аккаунт** — это сущность, привязанная к уникальному адресу, реализующая модель актора, т.е., в TON аккаунт и есть актор, действующий в рамках _Actor Model_, поэтому,  термины _аккаунт_ и _актор_ взаимозаменяемые.

**Ключевые особенности:**

* Все аккаунты взаимодействуют между собой исключительно через сообщения.
* Каждый аккаунт может содержать:
  * баланс (в TON и других токенах),
  * состояние,
  * код — то есть быть смарт-контрактом,
  * или не содержать код — например, быть обычным кошельком.

Даже без кода аккаунт остаётся полноправной сущностью. Он может принимать переводы и инициировать отправку сообщений.
Таким образом, структура всех аккаунтов в TON едина, а различие заключается лишь в наличии или отсутствии кода.

#### Баланс

**Баланс** — это количество токенов, закреплённое за аккаунтом.
В TON аккаунт может иметь баланс в основной валюте (TON) и других токенах (например, Jettons).

Баланс используется для оплаты:

* комиссий за отправку сообщений,
* хранения данных (storage fees),
* переводов другим аккаунтам.

Даже с нулевым балансом аккаунт остаётся валидным и может содержать код и данные.

#### Смарт контракт

Смарт-контракт в TON — это код, хранящийся в аккаунте, который выполняется при получении входящих сообщений.


#### Состояние

#### Адрес

#### Message feature
#### Transaction feature
#### Асинхронная природа транзакций

#### AccountChain
#### ShardChain
#### WorkChain
#### Type of WorkChain: MasterChain and BaseChain
#### Testnet and Mainnet

### Сообщения

* Сообщение
Все взаимодействия со смарт-контрактами в TON построены на сообщениях. Сообщения чем-то похожи на запросы к серверу. Каждый смарт-контракт имеет обработчик сообщений и выполняет определенную логику по приходу сообщения.

* Transaction and message real life examples
* Tl-B structure
* Message structure TL-B
  Теперь о данных в сообщении. Мы уже говорили что и в external, и internal сообщениях могут содержаться какие-то данные. Но как именно эти данные передавать? В TON все данные представлены в виде ячеек. Для того чтобы закодировать данные в ячейку, существует общепринятый стандарт для описания сериализации этих данных – TL-B.
  Простейший практический контракт в TON – это счетчик. Рассмотрим такой гипотетический пример и примеры возможных сообщений к нему. Пусть смарт-контракт может совершать два действия, увеличить или уменьшить внутреннюю переменную в нём. Тогда возможные сообщения описанные на языке TL-B будут выглядеть примерно так:

* Particular message structure
* Headers fields (CommonMsgInfo)
* Типы сообщений

Всего есть три типа сообщений:
- internal
- external incoming
- external outgoing


### Internal
Теперь об internal сообщениях. Когда кошелек получает external сообщение он проверяет подпись, и если всё корректно кошелек посылает уже internal сообщение на другой смарт-контракт. У internal сообщения есть несколько важных отличий – помимо данных, к сообщению может быть прикреплено некоторое количество TON, а ещё у internal сообщения есть отправитель, то есть в нашем примере отправитель это наш кошелек.

Говоря немного иначе internal сообщение – это сообщение от одного смарт-контракта к другому. При получении internal сообщения смарт-контракт знает сколько к этому сообщению было прикреплено TON и кто отправитель этого сообщения. Корректность этих данных гарантируется блокчейном, соответственно смарт-контракт может им доверять.

### External incoming
Начнём с external сообщений. External сообщение это просто сообщение с данными к конкретному смарт-контракту. То есть любой человек может отправить произвольные данные на любой смарт-контракт, а смарт-контракт решит, что с этим сообщением делать. Это относительно редко используемая логика, но у неё есть одно самое важное применение – контракты кошельков.

Почти любое действие в блокчейне начинается с external сообщения к кошельку. То есть, когда пользователь хочет кому-то перевести TON или например совершить обмен на DEX, он посылает external сообщение на свой кошелёк с подписанными данными.

### External outgoing
External-out (их ещё иногда называют Events) – это просто данные которые генерирует смарт-контракт и никуда не отправляет. Редкий тип сообщения, по своей сути очень похож на логи. По большей части нужен просто для облегчения индексации блокчейна. Например DeDust генерирует external out сообщение при успешном свапе, чтобы другим сервисам было проще отслеживать торговую активность.

External message examples and typical using
Internal message examples and typical using
Message value
Bounce of messages (они bouncable/unbouncable либо они могут быть или нет bouncable/unbouncable)
Address with flags as field of message
Trace
Action
External message is an initiation of Action
Define that we need build internal message and wrap this in external message.
* Serializators for messages. (Message builders)
* Types of message descriptors
  * Дополнительные стандарты с TL-B (https://github.com/ton-blockchain/TEPs/blob/master/text/0089-jetton-wallet-discovery.md)

#### Создание сообщение по TL-B

```
increase#34a3ff12 query_id:uint64 amount:uint32 = InternalMsgBody;
```

```
decrease#e4d5986b query_id:uint64 amount:uint32 = InternalMsgBody;
```

Это схема описывает 2 сообщения (сами данные). Когда мы работаем с сообщением, то тело сообщения и количество прикрепленных к нему TON – это два самых важных параметра.

В теле сообщения есть два конвенциональных поля – opcode и query_id. opcode – это 32-битное число означающее тип операции, а query_id – 64-битное число, которое смарт-контракт никак не должен использовать, и нужное лишь для удобства внешним сервисам.

Так в коде чтобы собрать тело сообщения

```
function generateMessageBody(amount: bigint): Cell {
const op = 0x34a3ff12;
const queryId = randomUint64();
const body = beginCell()
.storeUint(op, 32)
.storeUint(queryId, 64)
.storeUint(amount, 32)
.endCell();

    return body;
}
```
  * Build message serializer according to TL-B
  * Ресиверы в коде  (https://github.com/ton-blockchain/highload-wallet-contract-v3)
  * Build message serializer according to source code
  * Assembler (blockchain explorer preview/ https://tonviewer.com/EQDcN89ChMLQe4G-p5Tqk5qhH_PpY9lbhRjXNagmCGsg_9l1?section=code )

## Хэши в TON Blockchain

Хэши играют критически важную роль в экосистеме TON, обеспечивая идентификацию и верификацию данных на всех уровнях блокчейна. Понимание того, как работают хэши, поможет вам эффективно отслеживать транзакции, верифицировать сообщения и интегрировать ваши приложения с TON.

### Что такое хэш?

В контексте TON хэш — это уникальный криптографический отпечаток данных, вычисленный с помощью алгоритма SHA-256. Каждая ячейка (Cell), сообщение или транзакция имеют свой уникальный хэш, который служит их цифровой подписью.

:::info Важно
Хэши в TON необратимы — по хэшу нельзя восстановить исходные данные. Однако они детерминированы — одни и те же данные всегда дают одинаковый хэш.
:::

### Типы хэшей в TON

#### Хэш тела сообщения

Хэш тела сообщения — это уникальный идентификатор содержимого вашего сообщения. Он вычисляется от ячейки, содержащей данные сообщения.

**Практический пример:**

```typescript
import { beginCell } from '@ton/core';

// Создаем тело сообщения для увеличения счетчика
const messageBody = beginCell()
  .storeUint(0x34a3ff12, 32)  // opcode для операции "increase"
  .storeUint(0, 64)           // query_id
  .storeUint(5, 32)           // amount - увеличить на 5
  .endCell();

// Получаем хэш тела сообщения
const bodyHash = messageBody.hash();
console.log('Message Body Hash:', bodyHash.toString('hex'));
// Вывод: Message Body Hash: a1b2c3d4e5f6789...
```

**Когда использовать хэш тела сообщения:**
- Для проверки целостности данных
- При отладке и логировании операций
- Для дедупликации сообщений в вашем приложении

#### Хэш полного сообщения

Полное сообщение включает не только тело, но и заголовки с метаданными (отправитель, получатель, сумма, комиссии). Его хэш — это уникальный идентификатор всего сообщения.

**Практический пример:**

```typescript
import { storeMessage, beginCell, internal, Address } from '@ton/ton';
import { toNano } from '@ton/core';

// Создаем внутреннее сообщение
const internalMessage = internal({
  to: Address.parse('EQB...'), // адрес получателя
  value: toNano('0.1'),        // 0.1 TON
  body: messageBody             // тело сообщения из предыдущего примера
});

// Получаем хэш полного сообщения
const messageCell = beginCell()
  .store(storeMessage(internalMessage))
  .endCell();

const fullMessageHash = messageCell.hash();
console.log('Full Message Hash:', fullMessageHash.toString('hex'));
// Вывод: Full Message Hash: f1e2d3c4b5a6987...
```

**Когда использовать хэш полного сообщения:**
- Для отслеживания конкретных сообщений в блокчейне
- При работе с API TON Center для поиска транзакций
- Для верификации того, что сообщение не было изменено

#### Хэш транзакции

Хэш транзакции — это уникальный идентификатор всей транзакции, включающей входящие и исходящие сообщения, изменения состояния и комиссии.

**Практический пример получения хэша транзакции:**

```typescript
import { TonClient } from '@ton/ton';
import { Address } from '@ton/core';

const client = new TonClient({
  endpoint: 'https://toncenter.com/api/v2/jsonRPC',
  apiKey: 'your-api-key'
});

const transactions = await client.getTransactions(
  Address.parse('EQB...'), 
  { limit: 10 }
);

for (const tx of transactions) {
  const txHash = tx.hash();
  console.log('Transaction Hash:', txHash.toString('hex'));
  
  // Также можем получить хэш входящего сообщения
  if (tx.inMessage) {
    const inMsgCell = beginCell()
      .store(storeMessage(tx.inMessage))
      .endCell();
    const inMsgHash = inMsgCell.hash();
    console.log('Incoming Message Hash:', inMsgHash.toString('hex'));
  }
}
```

#### Хэш StateInit для верификации адресов

В TON Connect часто требуется верифицировать соответствие между адресом кошелька и его StateInit. Хэш StateInit должен совпадать с хэш-частью адреса.

**Практический пример верификации адреса:**

```typescript
import { Cell, Address, contractAddress } from '@ton/ton';

async function verifyWalletAddress(
  receivedAddress: string, 
  stateInitBase64: string
): Promise<boolean> {
  try {
    // Парсим StateInit из base64
    const stateInit = Cell.fromBase64(stateInitBase64);
    
    // Получаем хэш StateInit
    const stateInitHash = stateInit.hash();
    
    // Парсим полученный адрес
    const address = Address.parse(receivedAddress);
    
    // Проверяем, что хэш-часть адреса совпадает с хэшем StateInit
    const addressHashPart = stateInitHash.toString('hex');
    const expectedAddress = address.hash.toString('hex');
    
    console.log('StateInit Hash:', addressHashPart);
    console.log('Address Hash:', expectedAddress);
    
    return addressHashPart === expectedAddress;
  } catch (error) {
    console.error('Ошибка верификации адреса:', error);
    return false;
  }
}

// Пример использования в TON Connect
const isValidAddress = await verifyWalletAddress(
  '0:b2a1ecf5545e076cd36ae516ea7ebdf32aea008caa2b84af9866becb208895ad',
  'te6cckECFgEAAwQAAgE0ARUBFP8A9KQT9LzyyAs...'
);

if (isValidAddress) {
  console.log('Адрес верифицирован успешно!');
} else {
  console.log('Ошибка верификации адреса!');
}
```

#### Нормализованный хэш сообщения

Нормализованный хэш сообщения — это инновационное решение проблемы надежного отслеживания транзакций в TON. Согласно [TEP-467](https://github.com/ton-blockchain/TEPs/pull/467), этот подход обеспечивает стабильный идентификатор для external-in сообщений, устраняя влияние несущественных полей на хэш.

**Проблема, которую решает нормализация:**

Обычные хэши сообщений могут различаться для функционально идентичных сообщений из-за вариаций в полях `src`, `import_fee` и `init`. Это усложняет отслеживание транзакций и дедупликацию.

**Как работает нормализация:**

Нормализованный хэш вычисляется путем стандартизации следующих полей external-in сообщения:

1. **Source Address (`src`)**: Устанавливается в `addr_none$00`
2. **Import Fee (`import_fee`)**: Устанавливается в `0`
3. **InitState (`init`)**: Устанавливается в пустое значение
4. **Body**: Всегда сохраняется как ссылка

**Практический пример вычисления нормализованного хэша:**

```typescript
import { beginCell, storeMessage, external, Address, Cell } from '@ton/ton';

function computeNormalizedMessageHash(
  destination: Address,
  body: Cell
): string {
  // Создаем нормализованное external-in сообщение
  const normalizedMessage = external({
    to: destination,
    body: body,
    // Остальные поля автоматически нормализуются:
    // src устанавливается в addr_none
    // import_fee устанавливается в 0
    // init остается пустым
  });

  // Принудительно сохраняем body как ссылку для нормализации
  const normalizedCell = beginCell()
    .store(storeMessage(normalizedMessage))
    .endCell();

  // Вычисляем нормализованный хэш
  const normalizedHash = normalizedCell.hash();
  
  return normalizedHash.toString('hex');
}

// Пример использования
const messageBody = beginCell()
  .storeUint(0, 32) // opcode для простого перевода
  .storeStringTail('Normalized hash example')
  .endCell();

const destinationAddress = Address.parse('EQB...');
const normalizedHash = computeNormalizedMessageHash(destinationAddress, messageBody);

console.log('Normalized Message Hash:', normalizedHash);
```

**Сравнение обычного и нормализованного хэшей:**

```typescript
import { external, beginCell, storeMessage } from '@ton/ton';

async function compareMessageHashes(
  destination: Address,
  body: Cell
) {
  // Создаем обычное external сообщение
  const regularMessage = external({
    to: destination,
    body: body
  });

  // Вычисляем обычный хэш
  const regularCell = beginCell()
    .store(storeMessage(regularMessage))
    .endCell();
  const regularHash = regularCell.hash().toString('hex');

  // Вычисляем нормализованный хэш
  const normalizedHash = computeNormalizedMessageHash(destination, body);

  console.log('Regular Hash:', regularHash);
  console.log('Normalized Hash:', normalizedHash);
  
  // Нормализованный хэш остается стабильным даже если 
  // сообщение будет переупаковано нодами сети
  return {
    regular: regularHash,
    normalized: normalizedHash
  };
}
```

**Когда использовать нормализованный хэш:**

- **Отслеживание транзакций в реальном времени** — получите стабильный идентификатор сразу после отправки
- **Дедупликация сообщений** — избежите дублирования функционально идентичных операций  
- **TON Connect интеграции** — обеспечите надежную связь между фронтендом и бэкендом
- **Биржевые системы** — гарантируйте точное отслеживание пользовательских операций

**Уникальность и ограничения:**

Нормализованный хэш обеспечивает уникальность в типичных сценариях:

1. Сообщение отправляется на кошелек
2. Сообщение включает инструкцию с флагом IGNORE_ERRORS=+2
3. Кошелек никогда не удаляется

**Интеграция с существующими системами:**

```typescript
// Типы данных для отслеживания транзакций
interface TransactionData {
  destination: Address;
  body: Cell;
  metadata: any;
  timestamp: number;
  status: 'pending' | 'confirmed' | 'failed';
}

type TransactionStatus = 'pending' | 'confirmed' | 'failed';

// Адаптер для работы с нормализованными хэшами
class TransactionTracker {
  private pendingTransactions = new Map<string, TransactionData>();

  async trackTransaction(
    destination: Address,
    body: Cell,
    metadata: any
  ): Promise<string> {
    // Используем нормализованный хэш как постоянный ID
    const trackingId = computeNormalizedMessageHash(destination, body);
    
    this.pendingTransactions.set(trackingId, {
      destination,
      body,
      metadata,
      timestamp: Date.now(),
      status: 'pending'
    });

    console.log(`Транзакция отслеживается с ID: ${trackingId}`);
    return trackingId;
  }

  async checkTransactionStatus(trackingId: string): Promise<TransactionStatus> {
    const transaction = this.pendingTransactions.get(trackingId);
    if (!transaction) {
      throw new Error('Транзакция не найдена');
    }

    // Проверяем статус в блокчейне по нормализованному хэшу
    // Этот ID останется стабильным даже если сообщение было переупаковано
    return await this.queryBlockchainStatus(trackingId);
  }

  private async queryBlockchainStatus(normalizedHash: string): Promise<TransactionStatus> {
    // Реализация запроса к блокчейну
    // Нормализованный хэш обеспечивает надежное отслеживание
    return 'confirmed';
  }
}

// Пример использования
const tracker = new TransactionTracker();
const trackingId = await tracker.trackTransaction(walletAddress, messageBody, { 
  user: 'user123', 
  amount: '1.0 TON' 
});
```

Нормализованный хэш сообщения представляет собой значительный шаг вперед в надежности отслеживания транзакций TON. Это решение уже активно используется командами Tonkeeper и TonAPI, что подтверждает его практическую ценность для разработчиков.

### Отправка сообщения и проверка факта отправки

Один из наиболее важных сценариев — это отправить сообщение и убедиться, что оно было обработано блокчейном.

**Пошаговый процесс:**

```typescript
import { WalletContractV4, internal, TonClient } from '@ton/ton';
import { mnemonicToPrivateKey } from '@ton/crypto';
import { Address, toNano, beginCell } from '@ton/core';

async function sendAndVerifyMessage() {
  // 1. Создаем клиент и кошелек
  const client = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC'
  });
  
  const mnemonic = 'your mnemonic words here';
  const keyPair = await mnemonicToPrivateKey(mnemonic.split(' '));
  const wallet = client.open(WalletContractV4.create({
    publicKey: keyPair.publicKey,
    workchain: 0
  }));

  // 2. Создаем сообщение с комментарием
  const messageBody = beginCell()
    .storeUint(0, 32)           // opcode для простого перевода
    .storeStringTail('Hello TON!')
    .endCell();

  // 3. Отправляем транзакцию
  const seqno = await wallet.getSeqno();
  await wallet.sendTransfer({
    secretKey: keyPair.secretKey,
    seqno,
    messages: [internal({
      to: Address.parse('EQB...'),
      value: toNano('0.01'),
      body: messageBody
    })]
  });

  // 4. Проверяем факт отправки через некоторое время
  await new Promise(resolve => setTimeout(resolve, 10000)); // ждем 10 секунд
  
  const newSeqno = await wallet.getSeqno();
  if (newSeqno > seqno) {
    console.log('Транзакция успешно обработана!');
    
    // 5. Находим нашу транзакцию и получаем её хэш
    const transactions = await client.getTransactions(wallet.address, { limit: 5 });
    const ourTx = transactions.find(tx => 
      tx.inMessage?.info.type === 'external-in' && 
      tx.description.type === 'generic'
    );
    
    if (ourTx) {
      const txHash = ourTx.hash();
      console.log('Transaction Hash:', txHash.toString('hex'));
    }
  } else {
    console.log('Транзакция не была обработана');
  }
}
```

### Поиск транзакции по BOC

Когда вы отправляете транзакцию через TON Connect, вы получаете BOC (Bag of Cells). Вы можете использовать этот BOC для поиска соответствующей транзакции в блокчейне.

**Практический пример:**

```typescript
import { Cell, Address, beginCell, storeMessage, TonClient } from '@ton/ton';

async function findTransactionByBOC(
  externalBOC: string, 
  walletAddress: string
): Promise<string | null> {
  const client = new TonClient({
    endpoint: 'https://toncenter.com/api/v2/jsonRPC',
    apiKey: 'your-api-key'
  });

  try {
    // Получаем хэш внешнего BOC
    const extHash = Cell.fromBase64(externalBOC).hash().toString('hex');
    
    // Получаем последние транзакции кошелька
    const transactions = await client.getTransactions(
      Address.parse(walletAddress), 
      { limit: 10 }
    );
    
    for (const tx of transactions) {
      const inMsg = tx.inMessage;
      if (inMsg?.info.type === 'external-in') {
        // Создаем хэш входящего сообщения
        const inHash = beginCell()
          .store(storeMessage(inMsg))
          .endCell()
          .hash()
          .toString('hex');
        
        console.log('External BOC hash:', extHash);
        console.log('Transaction message hash:', inHash);
        
        // Если хэши совпадают, мы нашли нашу транзакцию
        if (extHash === inHash) {
          const txHash = tx.hash().toString('hex');
          console.log('Найдена транзакция:', txHash);
          return txHash;
        }
      }
    }
    
    throw new Error('Транзакция не найдена');
  } catch (error) {
    console.error('Ошибка поиска транзакции:', error);
    return null;
  }
}

// Пример использования
const txHash = await findTransactionByBOC(
  'te6cckEBAgEAqQAB4YgA+yKcnwQCs1xAwIEKKB4DvkIdXNjL6B...', 
  'EQB...'
);
```

### Практические советы

#### Проверка статуса транзакции через API

```typescript
// Проверяем статус транзакции по её хэшу
async function checkTransactionStatus(txHash: string, walletAddress: string) {
  try {
    const response = await fetch(
      `https://testnet.toncenter.com/api/v2/getTransactions?` +
      `address=${walletAddress}&hash=${txHash}`
    );
    const data = await response.json();
    
    if (data.result.length > 0) {
      console.log('Транзакция найдена в блокчейне');
      return data.result[0];
    } else {
      console.log('Транзакция не найдена');
      return null;
    }
  } catch (error) {
    console.error('Ошибка при проверке транзакции:', error);
    return null;
  }
}
```

#### Мониторинг в реальном времени

```typescript
// Пример функции для мониторинга входящих транзакций
async function monitorIncomingTransactions(walletAddress: Address, client: TonClient) {
  let lastLt = '0';
  
  setInterval(async () => {
    try {
      const transactions = await client.getTransactions(walletAddress, { 
        limit: 10,
        lt: lastLt
      });
      
      for (const tx of transactions) {
        if (tx.lt > lastLt) {
          const txHash = tx.hash();
          console.log('Новая транзакция:', txHash.toString('hex'));
          
          // Обрабатываем входящие сообщения
          if (tx.inMessage) {
            const msgCell = beginCell()
              .store(storeMessage(tx.inMessage))
              .endCell();
            const msgHash = msgCell.hash();
            console.log('Хэш сообщения:', msgHash.toString('hex'));
          }
          
          lastLt = tx.lt;
        }
      }
    } catch (error) {
      console.error('Ошибка мониторинга:', error);
    }
  }, 5000); // проверяем каждые 5 секунд
}
```

### Лучшие практики

1. **Всегда сохраняйте хэши**: Записывайте хэши важных транзакций и сообщений для последующего отслеживания.

2. **Используйте правильный тип хэша**: Для отслеживания транзакций используйте хэш транзакции, для верификации данных — хэш сообщения.

3. **Учитывайте время подтверждения**: В TON транзакции обычно подтверждаются за 3-6 секунд, но в периоды высокой нагрузки может потребоваться больше времени.

4. **Реализуйте retry логику**: Если транзакция не появилась в блокчейне в течение минуты, стоит проверить её статус или повторить отправку.

Хэши — это ваш надежный инструмент для работы с TON блокчейном. Используйте их правильно, и ваши приложения будут работать стабильно и предсказуемо.

## Отправка сообщения

Есть два практических и важных для отличия случая, как можно отправить сообщение в блокчейн. Либо мы отсылаем сообщение с бэкенда являемся владельцем кошелька и можем сразу подписать и отправить сообщение в блокчейн, либо используя TON Connect на фронтенде мы можем собрать сообщение и предложить пользователю подписать и отправить его самому.

### Отправка с бэкенда

Когда у нас есть кошелек с сид фразой отправление сообщения происходит так
Код [отсюда](/v3/guidelines/dapps/cookbook/#how-to-transfer-ton-and-send-a-text-message-to-another-wallet)

### Отправка с фронтенда (TON Connect)
Тут мы просто предлагаем пользователю подписать сообщение

```
const myTransaction = {
validUntil: Math.floor(Date.now() / 1000) + 60, // 60 sec
messages: [
{
address: destination, // Address of smart contract to send internal message to
amount: amount, // Amount in nanotons to attach to the message
payload: Base64.encode(messageBody.toBoc())
}
]
}

tonConnectUI.sendTransaction(myTransaction)

```
## Get методы
Get methods
Build get method wrapper
Get balance
Get jetton wallet address
Get collection data

## Blockchain HTTP API 
* Основные сервисы в TON: TON Center, TON API, TONX API.
* Транзакция это часть блока.
* Подходы к получению транзакции из блокчейна.
  * GetTranasction by external message.
  * Перебор все транзакции с последнего блока MasterChain. 
  * Использование верхнеуровневых интерфейсов для событий(или операций): GetJettons, GetNFTs, GetActions.
* Фундаментальный подход к получению массива транзакций.
Для получения всех транзакций используют метод сканирования сверху. Расмотрим алгоритм на примере TON Center HTTP API

- https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_masterchain_info
- https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_masterchainBlockShardState

Получить seqno последного MasterChain блока. Пусть мы получили N.
Метод api_v3_get_masterchainBlockShardState возращает последние блоки в каждом Shard каждого WorkChain (за исключением MasterChain, где всегда только один Shard).
1. Запросить шард стет для MasterChain блока с seqno = N, сравнить его Shard state с Shard ateate для MasterChain блока N-1.
2. Существует 3 возможных ситуации для каждого Shard:
   a. Обычный случа: Было 0, 1 или более новых блоков в текущем шарде. Вам потребуется сканировать все эти блоки.
   b. Split：　Один шард исчез, появилось два новых, с новыми ID шарда. Новых блоков не может быть созданно в процессе разделения.
   с. Merge: Исчезло два шарда S1, S2 в N-1, и появился новый шард с seqno max(S1,S2)+ 1 в N. Нам нужны блоки которые появились в новом шарде.
3. Соберите список всех "новых" блоков между MasterChain блоками N-1 и N.
4. Получить все транзакции по этим блокам используя метод https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_transactions .

Этот алгоритм уже имплементирован в методе https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_transactions_by_masterchain_block.
Но для большей безопасности рекомендуется самостоятельно процессить транзакции по блокам.

## Транзакция
….
Поля Транзакции
Транзакция в TVM и фазы

В TVM каждая транзакция выполняется по этапам:

1. **Storage phase**: Загружаем текущий стейт аккаунта в VM
2. **Credit phase**: Берем средства на выполнение инструкций
3. **Compute phase**: Выполнение контракта
4. **Action phase**: Отправка сообщений
5. **Bounce phase**: Обработка ошибок

# Успешность транзакции
1. Фаза Compute, Action возвращает Exit code в результате работы. Если они оба равны 0 (или 1) - транзакция выполнена успешно.
2. Однако, транзакция может не выполниться и отклониться ещё до выполнения Credit phase, Compute phase, Action phase - тогда Exit code не будет получен вовсе, и транзакция тоже не является успешной.
3. В контрактах расширяется логика Exit code TVM и добавляются дополнительные ошибочные коды для улучшения дебага. Но успешность выполнения транзакции как и всегда описывается Exit code.

Успешность операции (Event, Actions)
1. Успешность операции не является тем же самым что успешность транзакции.
Transaction success verified
Action success verified

